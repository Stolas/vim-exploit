" VIM Exploit Development
" GPLv3

if !exists('g:exploit_author')
    let g:exploit_author = $USER
endif

if !exists('g:exploit_copyright')
    let g:exploit_copyright = "Exploit by: ".exploit_author.", written with VIM-Exploit."
endif

if !exists('g:exploit_1337_banner')
    let g:exploit_1337_banner = ""
endif

if !exists('g:quick_cyclic_pattern_size')
    let g:quick_cyclic_pattern_size = 80
endif

" normalize the path
" replace the windows path sep \ with /
function! <SID>NormalizePath(path)
    return substitute(a:path, "\\", "/", "g")
endfunction

" Template searching. {{{1
" Returns a string containing the path of the parent directory of the given
" path. Works like dirname(3). It also simplifies the given path.
function! <SID>DirName(path)
    let l:tmp = <SID>NormalizePath(a:path)
    return substitute(l:tmp, "[^/][^/]*/*$", "", "")
endfunction

" Default templates directory
let s:default_template_dir = <SID>DirName(<SID>DirName(expand("<sfile>"))) . "templates"


" Exploit Development Features
function! ExploitGenerateCyclicPattern(size)
    let l:uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    let l:lowercase = "abcdefghijklmnopqrstuvwxyz"
    let l:digits    = "0123456789"
    let l:extended  = ",.;+=-_!&()#@({})[]%"

    let l:max_size = len(l:uppercase) * len(l:lowercase) * len(l:digits) * 3
    " Todo: Later.
    "if a:size > max_size
    "    echom "To big including extended."
    "    let l:max_size = len(l:uppercase) * len(l:lowercase) * len(l:digits) * len(l:extended) * 3
    "    if a:size > max_size
    "        echo "Size " . a:size . " is bigger than max size: " . l:max_size
    "    endif
    "endif

    let l:pattern = ""
    while len(l:pattern) < a:size
        for one in split(l:uppercase, '\zs')
            for two in split(l:lowercase, '\zs')
                for three in split(l:digits, '\zs')
                    if len(l:pattern) < a:size
                        let l:pattern .= one
                    endif

                    if len(l:pattern) < a:size
                        let l:pattern .= two
                    endif

                    if len(l:pattern) < a:size
                        let l:pattern .= three
                    endif

                endfor
            endfor
        endfor
    endwhile
    return l:pattern
endfunction

function! ExploitInsertCyclicPattern(size)
    put = ExploitGenerateCyclicPattern(a:size)
endfunction

function! ExploitAskSizeCyclicPattern()
    let l:amount = inputdialog("Size for Cyclic Pattern?")
    if l:amount > 0
        call ExploitInsertCyclicPattern(l:amount)
    endif
endfunction


function! ExploitFindCyclicPattern(offset, size)
    echom "Offset is ".strridx(ExploitGenerateCyclicPattern(a:size), a:offset)
endfunction

function! ExploitFindCyclicPatternQuick(offset)
    echom "Offset is ".strridx(ExploitGenerateCyclicPattern(g:quick_cyclic_pattern_size), a:offset)
endfunction

command! ExploitCyclicPattern call ExploitAskSizeCyclicPattern()
command! ExploitCyclicPatternQuick call ExploitInsertCyclicPattern(g:quick_cyclic_pattern_size)

function! ExploitInsertFullByte(linebreaks, skip_filetype)
    let l:pre_block = ""
    let l:post_block = ""
    let l:pre_line = ""
    let l:post_line = ""

    if a:skip_filetype == 0
        if exists("g:exploit_ignore_filetype")
        else
            " Todo: This needs cleanup.
            if &filetype ==# "c"
                let l:pre_block = "char buffer[] = \""
                let l:post_block = "\";"
                if a:linebreaks == 1
                    let l:pre_block = "char buffer[] = "
                    let l:post_block = ";"
                    let l:pre_line = "\""
                    let l:post_line = "\""
                endif
            elseif &filetype ==# "python"
                echom "Todo, Sorry"
            endif
        endif
    endif

    if a:linebreaks == 1
        let l:break = "\n"
    else
        let l:break = ""
    endif
    let l:b = l:pre_block
    let l:b = l:b.l:pre_line."\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef".l:post_line.l:break
    let l:b = l:b.l:pre_line."\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff".l:post_line.l:break
    let l:b = l:b.l:post_block
    put = l:b
endfunction
command! ExploitBadChar call ExploitInsertFullByte(0, 0)
command! ExploitBadCharBr call ExploitInsertFullByte(1, 0)

function! ExploitNew(split_way)
    " Todo: Parse a:split_way
    let l:template_type = confirm("--Exploit Kind--", "&Remote\n&Local\n&IRC", 0)
    let l:template_framework = confirm("--Exploit Framework--", "&Python\n&Metasploit\n&C", 0)
endfunction
command! ExploitEnew call ExploitNew('enew')
command! ExploitVnew call ExploitNew('vnew')
command! ExploitNew call ExploitNew('new')
